

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>owlapy.agen_kg.graph_extractor &mdash; OWLAPY 1.6.3 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=677a9ea0" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=9edc463e" />
      <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../../_static/theme.css?v=ea877efc" />
      <link rel="stylesheet" type="text/css" href="../../../_static/theme_tweak.css?v=f0ad19f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=677a9ea0" />

  
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=452006c5"></script>
      <script src="../../../_static/doctools.js?v=fd6eb6e6"></script>
      <script src="../../../_static/sphinx_highlight.js?v=6ffebe34"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            OWLAPY
              <img src="../../../_static/owlapy_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../usage/main.html">About owlapy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../usage/usage_examples.html">Basic Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../usage/ontologies.html">Ontologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../usage/reasoner.html">Reasoners</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../usage/owlapi_synchronization.html">Owlapi Synchronization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../usage/further_resources.html">Further Resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../autoapi/owlapy/index.html">owlapy</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">OWLAPY</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">owlapy.agen_kg.graph_extractor</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for owlapy.agen_kg.graph_extractor</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">re</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Optional</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">dspy</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">owlapy.owl_literal</span><span class="w"> </span><span class="kn">import</span> <span class="n">OWLLiteral</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">owlapy.owl_ontology</span><span class="w"> </span><span class="kn">import</span> <span class="n">Ontology</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">owlapy.agen_kg.signatures</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span><span class="n">EntityDeduplication</span><span class="p">,</span> <span class="n">CoherenceChecker</span><span class="p">,</span> <span class="n">TypeClustering</span><span class="p">,</span>
                                       <span class="n">RelationClustering</span><span class="p">,</span> <span class="n">TextSummarizer</span><span class="p">,</span> <span class="n">ChunkSummarizer</span><span class="p">,</span>
                                       <span class="n">EntityDeduplicationWithSummary</span><span class="p">,</span>
                                       <span class="n">TypeClusteringWithSummary</span><span class="p">,</span> <span class="n">RelationClusteringWithSummary</span><span class="p">,</span>
                                       <span class="n">IncrementalEntityMerger</span><span class="p">,</span>
                                       <span class="n">IncrementalTripleMerger</span><span class="p">,</span> <span class="n">IncrementalTypeMerger</span><span class="p">,</span> <span class="n">PlanDecomposer</span>
                                       <span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">owlapy.agen_kg.text_loader</span><span class="w"> </span><span class="kn">import</span> <span class="n">UniversalTextLoader</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">owlapy.agen_kg.chunking_models.simple_chunker</span><span class="w"> </span><span class="kn">import</span> <span class="n">TextChunker</span>


<span class="c1"># A compatible metaclass that combines dspy.Module&#39;s metaclass with ABCMeta</span>
<div class="viewcode-block" id="GraphExtractorMeta">
<a class="viewcode-back" href="../../../autoapi/owlapy/agen_kg/graph_extractor/index.html#owlapy.agen_kg.graph_extractor.GraphExtractorMeta">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">GraphExtractorMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">dspy</span><span class="o">.</span><span class="n">Module</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">ABC</span><span class="p">)):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Metaclass that resolves conflicts between dspy.Module and ABC.&quot;&quot;&quot;</span>
    <span class="k">pass</span></div>



<div class="viewcode-block" id="GraphExtractor">
<a class="viewcode-back" href="../../../autoapi/owlapy/agen_kg/graph_extractor/index.html#owlapy.agen_kg.graph_extractor.GraphExtractor">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">GraphExtractor</span><span class="p">(</span><span class="n">dspy</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">GraphExtractorMeta</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for all graph extractors.</span>
<span class="sd">    Provides common functionality for entity clustering, coherence checking,</span>
<span class="sd">    text chunking for large documents, and utility methods shared across all extractor types.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">enable_logging</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">use_incremental_merging</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the graph extractor.</span>

<span class="sd">        Args:</span>
<span class="sd">            enable_logging: Whether to enable logging.</span>
<span class="sd">            use_incremental_merging: Whether to use incremental LLM-based merging for entities, triples,</span>
<span class="sd">                and type assertions. If False, uses simple direct merging without LLM calls (default: True).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fact_checking_instructions</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">triple_with_literal_extraction_instructions</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">literal_extraction_instructions</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type_assertion_instructions</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type_generation_instructions</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">triple_extraction_instructions</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">entity_extraction_instructions</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logging</span> <span class="o">=</span> <span class="n">enable_logging</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_incremental_merging</span> <span class="o">=</span> <span class="n">use_incremental_merging</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plan_decomposer</span> <span class="o">=</span> <span class="n">dspy</span><span class="o">.</span><span class="n">ChainOfThought</span><span class="p">(</span><span class="n">PlanDecomposer</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">entity_deduplicator</span> <span class="o">=</span> <span class="n">dspy</span><span class="o">.</span><span class="n">Predict</span><span class="p">(</span><span class="n">EntityDeduplication</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coherence_checker</span> <span class="o">=</span> <span class="n">dspy</span><span class="o">.</span><span class="n">Predict</span><span class="p">(</span><span class="n">CoherenceChecker</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type_clusterer</span> <span class="o">=</span> <span class="n">dspy</span><span class="o">.</span><span class="n">Predict</span><span class="p">(</span><span class="n">TypeClustering</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relation_clusterer</span> <span class="o">=</span> <span class="n">dspy</span><span class="o">.</span><span class="n">Predict</span><span class="p">(</span><span class="n">RelationClustering</span><span class="p">)</span>
        <span class="c1"># Summarization-based clustering (for large texts)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">entity_deduplicator_with_summary</span> <span class="o">=</span> <span class="n">dspy</span><span class="o">.</span><span class="n">Predict</span><span class="p">(</span><span class="n">EntityDeduplicationWithSummary</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type_clusterer_with_summary</span> <span class="o">=</span> <span class="n">dspy</span><span class="o">.</span><span class="n">Predict</span><span class="p">(</span><span class="n">TypeClusteringWithSummary</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relation_clusterer_with_summary</span> <span class="o">=</span> <span class="n">dspy</span><span class="o">.</span><span class="n">Predict</span><span class="p">(</span><span class="n">RelationClusteringWithSummary</span><span class="p">)</span>
        <span class="c1"># Summarization modules</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">text_summarizer</span> <span class="o">=</span> <span class="n">dspy</span><span class="o">.</span><span class="n">Predict</span><span class="p">(</span><span class="n">TextSummarizer</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chunk_summarizer</span> <span class="o">=</span> <span class="n">dspy</span><span class="o">.</span><span class="n">Predict</span><span class="p">(</span><span class="n">ChunkSummarizer</span><span class="p">)</span>
        <span class="c1"># Incremental merging modules</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">entity_merger</span> <span class="o">=</span> <span class="n">dspy</span><span class="o">.</span><span class="n">Predict</span><span class="p">(</span><span class="n">IncrementalEntityMerger</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">triple_merger</span> <span class="o">=</span> <span class="n">dspy</span><span class="o">.</span><span class="n">Predict</span><span class="p">(</span><span class="n">IncrementalTripleMerger</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type_merger</span> <span class="o">=</span> <span class="n">dspy</span><span class="o">.</span><span class="n">Predict</span><span class="p">(</span><span class="n">IncrementalTypeMerger</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">text_loader</span> <span class="o">=</span> <span class="n">UniversalTextLoader</span><span class="p">(</span><span class="n">enable_logging</span><span class="o">=</span><span class="n">enable_logging</span><span class="p">)</span>
        <span class="c1"># Default text chunker - can be configured via configure_chunking()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">text_chunker</span> <span class="o">=</span> <span class="n">TextChunker</span><span class="p">(</span>
            <span class="n">chunk_size</span><span class="o">=</span><span class="mi">6000</span><span class="p">,</span>  <span class="c1"># ~1500 tokens</span>
            <span class="n">overlap</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span>
            <span class="n">strategy</span><span class="o">=</span><span class="s2">&quot;paragraph&quot;</span><span class="p">,</span>
            <span class="n">enable_logging</span><span class="o">=</span><span class="n">enable_logging</span>
        <span class="p">)</span>
        <span class="c1"># Threshold for automatic chunking (in characters)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">auto_chunk_threshold</span> <span class="o">=</span> <span class="mi">4000</span>  <span class="c1"># ~1000 tokens</span>
        <span class="c1"># Threshold for using summarization in clustering (in characters)</span>
        <span class="c1"># When text exceeds this, use summarization-based clustering</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">summarization_threshold</span> <span class="o">=</span> <span class="mi">8000</span>  <span class="c1"># ~2000 tokens</span>
        <span class="c1"># Maximum summary length (in characters) for clustering context</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_summary_length</span> <span class="o">=</span> <span class="mi">3000</span>  <span class="c1"># ~750 tokens</span>
        <span class="c1"># Cache for chunk summaries (chunk_text_hash -&gt; summary)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_chunk_summary_cache</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Maximum cache size to prevent memory leaks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_cache_size</span> <span class="o">=</span> <span class="mi">1000</span>

<div class="viewcode-block" id="GraphExtractor.snake_case">
<a class="viewcode-back" href="../../../autoapi/owlapy/agen_kg/graph_extractor/index.html#owlapy.agen_kg.graph_extractor.GraphExtractor.snake_case">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">snake_case</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
        <span class="c1"># Normalize whitespace and special chars</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[^\w\s]&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>  <span class="c1"># Remove special chars</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\s+&#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="n">text</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>  <span class="c1"># Multiple spaces -&gt; single underscore</span>
        <span class="k">return</span> <span class="n">text</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span></div>


<div class="viewcode-block" id="GraphExtractor.format_type_name">
<a class="viewcode-back" href="../../../autoapi/owlapy/agen_kg/graph_extractor/index.html#owlapy.agen_kg.graph_extractor.GraphExtractor.format_type_name">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">format_type_name</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Format a type name to start with capital letter and rest lowercase.</span>
<span class="sd">        E.g., &#39;PERSON&#39; -&gt; &#39;Person&#39;, &#39;person&#39; -&gt; &#39;Person&#39;, &#39;PERSON_TYPE&#39; -&gt; &#39;Person_type&#39;</span>

<span class="sd">        Args:</span>
<span class="sd">            text: The type name to format.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Formatted type name with capital first letter and lowercase rest.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Normalize whitespace and special chars</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[^\w\s]&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>  <span class="c1"># Remove special chars</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\s+&#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="n">text</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>  <span class="c1"># Multiple spaces -&gt; single underscore</span>
        <span class="c1"># Convert to lowercase first, then capitalize first letter</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">text</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="n">text</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">+</span> <span class="n">text</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">return</span> <span class="n">text</span></div>



<div class="viewcode-block" id="GraphExtractor.plan_decompose">
<a class="viewcode-back" href="../../../autoapi/owlapy/agen_kg/graph_extractor/index.html#owlapy.agen_kg.graph_extractor.GraphExtractor.plan_decompose">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plan_decompose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">query</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">query</span> <span class="o">=</span> <span class="s2">&quot;Extract knowledge graph relevant information from the provided text.&quot;</span>

        <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plan_decomposer</span><span class="p">(</span><span class="n">user_request</span><span class="o">=</span><span class="n">query</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">entity_extraction_instructions</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">entity_extraction_task</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">triple_extraction_instructions</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">triple_extraction_task</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type_generation_instructions</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">type_generation_task</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type_assertion_instructions</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">type_assertion_task</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">literal_extraction_instructions</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">literal_extraction_task</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">triple_with_literal_extraction_instructions</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">triple_with_literal_extraction_task</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fact_checking_instructions</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">fact_checking_task</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">: INFO :: Decomposed the query into specific instructions&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="GraphExtractor.load_text">
<a class="viewcode-back" href="../../../autoapi/owlapy/agen_kg/graph_extractor/index.html#owlapy.agen_kg.graph_extractor.GraphExtractor.load_text">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">load_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">],</span> <span class="n">file_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load text from various sources (files or raw text).</span>

<span class="sd">        Supports multiple file formats:</span>
<span class="sd">        - Plain text: .txt</span>
<span class="sd">        - PDF: .pdf</span>
<span class="sd">        - Word documents: .docx, .doc</span>
<span class="sd">        - Rich Text: .rtf</span>
<span class="sd">        - HTML: .html, .htm</span>
<span class="sd">        - Raw text strings</span>

<span class="sd">        Args:</span>
<span class="sd">            source: File path (str or Path) or raw text string.</span>
<span class="sd">            file_type: Optional file extension (e.g., &#39;.pdf&#39;, &#39;.txt&#39;).</span>
<span class="sd">                      If not provided, will be auto-detected from the source.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Extracted text content as a string.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the file type is not supported or content cannot be extracted.</span>
<span class="sd">            FileNotFoundError: If the specified file does not exist.</span>

<span class="sd">        Examples:</span>
<span class="sd">            # Load from file</span>
<span class="sd">            text = extractor.load_text(&#39;document.pdf&#39;)</span>
<span class="sd">            text = extractor.load_text(&#39;/path/to/file.docx&#39;)</span>

<span class="sd">            # Load from raw text</span>
<span class="sd">            text = extractor.load_text(&#39;This is raw text input&#39;)</span>

<span class="sd">            # Specify file type explicitly</span>
<span class="sd">            text = extractor.load_text(&#39;file.txt&#39;, file_type=&#39;.txt&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">text_loader</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">file_type</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">: ERROR :: Failed to load text from source: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">raise</span></div>


<div class="viewcode-block" id="GraphExtractor.get_supported_formats">
<a class="viewcode-back" href="../../../autoapi/owlapy/agen_kg/graph_extractor/index.html#owlapy.agen_kg.graph_extractor.GraphExtractor.get_supported_formats">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_supported_formats</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get list of supported file formats.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of supported file extensions (e.g., [&#39;.txt&#39;, &#39;.pdf&#39;, &#39;.docx&#39;, ...])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">text_loader</span><span class="o">.</span><span class="n">supported_formats</span></div>


<div class="viewcode-block" id="GraphExtractor.configure_chunking">
<a class="viewcode-back" href="../../../autoapi/owlapy/agen_kg/graph_extractor/index.html#owlapy.agen_kg.graph_extractor.GraphExtractor.configure_chunking">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">configure_chunking</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">chunk_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">overlap</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">strategy</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">auto_chunk_threshold</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">summarization_threshold</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">max_summary_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Configure text chunking settings for handling large documents.</span>

<span class="sd">        This method allows fine-tuning of how large texts are split into</span>
<span class="sd">        manageable pieces for LLM processing.</span>

<span class="sd">        Args:</span>
<span class="sd">            chunk_size: Maximum characters per chunk (default: 3000, ~750 tokens).</span>
<span class="sd">            overlap: Characters to overlap between chunks (default: 200).</span>
<span class="sd">            strategy: Chunking strategy - &quot;sentence&quot;, &quot;paragraph&quot;, or &quot;fixed&quot;.</span>
<span class="sd">            auto_chunk_threshold: Character threshold for automatic chunking (default: 4000).</span>
<span class="sd">                                 Texts larger than this will be automatically chunked.</span>
<span class="sd">            summarization_threshold: Character threshold for using summarization in clustering</span>
<span class="sd">                                    (default: 8000). When text exceeds this, summaries are</span>
<span class="sd">                                    generated to provide context for clustering operations.</span>
<span class="sd">            max_summary_length: Maximum length of summaries used for clustering context</span>
<span class="sd">                               (default: 3000, ~750 tokens).</span>

<span class="sd">        Example:</span>
<span class="sd">            # Configure for a model with smaller context window</span>
<span class="sd">            extractor.configure_chunking(chunk_size=2000, overlap=150, strategy=&quot;sentence&quot;)</span>

<span class="sd">            # Configure for larger context window (e.g., GPT-4-turbo)</span>
<span class="sd">            extractor.configure_chunking(chunk_size=8000, overlap=500)</span>

<span class="sd">            # Configure summarization thresholds</span>
<span class="sd">            extractor.configure_chunking(summarization_threshold=10000, max_summary_length=4000)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">chunk_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">overlap</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">strategy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">text_chunker</span> <span class="o">=</span> <span class="n">TextChunker</span><span class="p">(</span>
                <span class="n">chunk_size</span><span class="o">=</span><span class="n">chunk_size</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">text_chunker</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">,</span>
                <span class="n">overlap</span><span class="o">=</span><span class="n">overlap</span> <span class="k">if</span> <span class="n">overlap</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">text_chunker</span><span class="o">.</span><span class="n">overlap</span><span class="p">,</span>
                <span class="n">strategy</span><span class="o">=</span><span class="n">strategy</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">text_chunker</span><span class="o">.</span><span class="n">strategy</span><span class="p">,</span>
                <span class="n">enable_logging</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logging</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">auto_chunk_threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">auto_chunk_threshold</span> <span class="o">=</span> <span class="n">auto_chunk_threshold</span>

        <span class="k">if</span> <span class="n">summarization_threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">summarization_threshold</span> <span class="o">=</span> <span class="n">summarization_threshold</span>

        <span class="k">if</span> <span class="n">max_summary_length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_summary_length</span> <span class="o">=</span> <span class="n">max_summary_length</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">: INFO :: Chunking configured - &quot;</span>
                  <span class="sa">f</span><span class="s2">&quot;chunk_size=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">text_chunker</span><span class="o">.</span><span class="n">chunk_size</span><span class="si">}</span><span class="s2">, &quot;</span>
                  <span class="sa">f</span><span class="s2">&quot;overlap=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">text_chunker</span><span class="o">.</span><span class="n">overlap</span><span class="si">}</span><span class="s2">, &quot;</span>
                  <span class="sa">f</span><span class="s2">&quot;strategy=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">text_chunker</span><span class="o">.</span><span class="n">strategy</span><span class="si">}</span><span class="s2">, &quot;</span>
                  <span class="sa">f</span><span class="s2">&quot;auto_threshold=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">auto_chunk_threshold</span><span class="si">}</span><span class="s2">, &quot;</span>
                  <span class="sa">f</span><span class="s2">&quot;summarization_threshold=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">summarization_threshold</span><span class="si">}</span><span class="s2">, &quot;</span>
                  <span class="sa">f</span><span class="s2">&quot;max_summary_length=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">max_summary_length</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="GraphExtractor.configure_chunking_for_model">
<a class="viewcode-back" href="../../../autoapi/owlapy/agen_kg/graph_extractor/index.html#owlapy.agen_kg.graph_extractor.GraphExtractor.configure_chunking_for_model">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">configure_chunking_for_model</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">max_context_tokens</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
            <span class="n">prompt_overhead_tokens</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1500</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Automatically configure chunking based on model specifications.</span>

<span class="sd">        This is a convenience method that calculates optimal chunk size</span>
<span class="sd">        based on your model&#39;s context window.</span>

<span class="sd">        Args:</span>
<span class="sd">            max_context_tokens: Maximum context window of your model (e.g., 4096 for GPT-3.5).</span>
<span class="sd">            prompt_overhead_tokens: Estimated tokens used by prompts/few-shot examples.</span>

<span class="sd">        Example:</span>
<span class="sd">            # For GPT-3.5-turbo (4K context)</span>
<span class="sd">            extractor.configure_chunking_for_model(4096, 1000)</span>

<span class="sd">            # For GPT-4 (8K context)</span>
<span class="sd">            extractor.configure_chunking_for_model(8192, 1500)</span>

<span class="sd">            # For GPT-4-turbo (128K context)</span>
<span class="sd">            extractor.configure_chunking_for_model(128000, 2000)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">chunk_size</span> <span class="o">=</span> <span class="n">TextChunker</span><span class="o">.</span><span class="n">calculate_chunk_size_for_model</span><span class="p">(</span>
            <span class="n">max_context_tokens</span><span class="p">,</span>
            <span class="n">prompt_overhead_tokens</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">configure_chunking</span><span class="p">(</span><span class="n">chunk_size</span><span class="o">=</span><span class="n">chunk_size</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">: INFO :: Configured for model with &quot;</span>
                  <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">max_context_tokens</span><span class="si">}</span><span class="s2"> token context window, &quot;</span>
                  <span class="sa">f</span><span class="s2">&quot;chunk_size=</span><span class="si">{</span><span class="n">chunk_size</span><span class="si">}</span><span class="s2"> chars&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="GraphExtractor.should_chunk_text">
<a class="viewcode-back" href="../../../autoapi/owlapy/agen_kg/graph_extractor/index.html#owlapy.agen_kg.graph_extractor.GraphExtractor.should_chunk_text">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">should_chunk_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine if text should be chunked based on its size.</span>

<span class="sd">        Args:</span>
<span class="sd">            text: The text to check.</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if text exceeds the auto_chunk_threshold.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">auto_chunk_threshold</span></div>


<div class="viewcode-block" id="GraphExtractor.chunk_text">
<a class="viewcode-back" href="../../../autoapi/owlapy/agen_kg/graph_extractor/index.html#owlapy.agen_kg.graph_extractor.GraphExtractor.chunk_text">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">chunk_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Split text into chunks for processing.</span>

<span class="sd">        Args:</span>
<span class="sd">            text: The text to chunk.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of text chunks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">text_chunker</span><span class="o">.</span><span class="n">chunk_text</span><span class="p">(</span><span class="n">text</span><span class="p">)</span></div>


<div class="viewcode-block" id="GraphExtractor.get_chunking_info">
<a class="viewcode-back" href="../../../autoapi/owlapy/agen_kg/graph_extractor/index.html#owlapy.agen_kg.graph_extractor.GraphExtractor.get_chunking_info">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_chunking_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get information about how a text would be chunked.</span>

<span class="sd">        Args:</span>
<span class="sd">            text: The text to analyze.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dictionary with chunking information including number of chunks,</span>
<span class="sd">            chunk sizes, etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">text_chunker</span><span class="o">.</span><span class="n">get_chunk_info</span><span class="p">(</span><span class="n">text</span><span class="p">)</span></div>


<div class="viewcode-block" id="GraphExtractor.should_use_summarization">
<a class="viewcode-back" href="../../../autoapi/owlapy/agen_kg/graph_extractor/index.html#owlapy.agen_kg.graph_extractor.GraphExtractor.should_use_summarization">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">should_use_summarization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine if text is large enough to require summarization for clustering.</span>

<span class="sd">        Args:</span>
<span class="sd">            text: The text to check.</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if text exceeds the summarization_threshold.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">summarization_threshold</span></div>


<div class="viewcode-block" id="GraphExtractor.summarize_chunk">
<a class="viewcode-back" href="../../../autoapi/owlapy/agen_kg/graph_extractor/index.html#owlapy.agen_kg.graph_extractor.GraphExtractor.summarize_chunk">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">summarize_chunk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chunk</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a summary of a text chunk that preserves key entities and relationships.</span>

<span class="sd">        Args:</span>
<span class="sd">            chunk: Text chunk to summarize.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Summary of the chunk.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check cache first</span>
        <span class="n">chunk_hash</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">chunk_hash</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chunk_summary_cache</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chunk_summary_cache</span><span class="p">[</span><span class="n">chunk_hash</span><span class="p">]</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">text_summarizer</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="n">chunk</span><span class="p">)</span>
        <span class="n">summary</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">summary</span>

        <span class="c1"># Cache the summary with size limit</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_chunk_summary_cache</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_cache_size</span><span class="p">:</span>
            <span class="c1"># Remove oldest entry (first key) to prevent unbounded growth</span>
            <span class="n">first_key</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_chunk_summary_cache</span><span class="p">))</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chunk_summary_cache</span><span class="p">[</span><span class="n">first_key</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">: INFO :: Cache limit reached, evicted oldest entry&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_chunk_summary_cache</span><span class="p">[</span><span class="n">chunk_hash</span><span class="p">]</span> <span class="o">=</span> <span class="n">summary</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">: INFO :: Summarized chunk from </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">summary</span><span class="p">)</span><span class="si">}</span><span class="s2"> chars&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">summary</span></div>


<div class="viewcode-block" id="GraphExtractor.summarize_chunks">
<a class="viewcode-back" href="../../../autoapi/owlapy/agen_kg/graph_extractor/index.html#owlapy.agen_kg.graph_extractor.GraphExtractor.summarize_chunks">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">summarize_chunks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chunks</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate summaries for multiple text chunks.</span>

<span class="sd">        Args:</span>
<span class="sd">            chunks: List of text chunks.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of chunk summaries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">summaries</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">chunks</span><span class="p">):</span>
            <span class="n">summary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">summarize_chunk</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
            <span class="n">summaries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">summary</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">: INFO :: Generated summary for chunk </span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">summaries</span></div>


<div class="viewcode-block" id="GraphExtractor.create_combined_summary">
<a class="viewcode-back" href="../../../autoapi/owlapy/agen_kg/graph_extractor/index.html#owlapy.agen_kg.graph_extractor.GraphExtractor.create_combined_summary">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">create_combined_summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chunk_summaries</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Combine multiple chunk summaries into a unified summary for clustering context.</span>

<span class="sd">        Args:</span>
<span class="sd">            chunk_summaries: List of summaries from individual chunks.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A combined summary suitable for clustering operations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If summaries are small enough, just concatenate them</span>
        <span class="n">total_length</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">chunk_summaries</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">total_length</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_summary_length</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">chunk_summaries</span><span class="p">)</span>

        <span class="c1"># Otherwise, use LLM to combine them</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_summarizer</span><span class="p">(</span><span class="n">chunk_summaries</span><span class="o">=</span><span class="n">chunk_summaries</span><span class="p">)</span>
        <span class="n">combined</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">combined_summary</span>

        <span class="c1"># Truncate if still too long</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">combined</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_summary_length</span><span class="p">:</span>
            <span class="n">combined</span> <span class="o">=</span> <span class="n">combined</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">max_summary_length</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">: INFO :: Combined </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">chunk_summaries</span><span class="p">)</span><span class="si">}</span><span class="s2"> summaries into </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">combined</span><span class="p">)</span><span class="si">}</span><span class="s2"> chars&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">combined</span></div>


<div class="viewcode-block" id="GraphExtractor.get_clustering_context">
<a class="viewcode-back" href="../../../autoapi/owlapy/agen_kg/graph_extractor/index.html#owlapy.agen_kg.graph_extractor.GraphExtractor.get_clustering_context">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_clustering_context</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">chunks</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get appropriate context for clustering operations based on text size.</span>

<span class="sd">        For small texts, returns the text directly (possibly truncated).</span>
<span class="sd">        For large texts, generates a summary to use as clustering context.</span>

<span class="sd">        Args:</span>
<span class="sd">            text: The full text.</span>
<span class="sd">            chunks: Optional pre-computed chunks of the text.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Context string suitable for clustering operations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># For small texts, use the text directly</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">should_use_summarization</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_summary_length</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">text</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">max_summary_length</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">text</span>

        <span class="c1"># For large texts, generate summary</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">: INFO :: Text exceeds summarization threshold, generating summary for clustering&quot;</span><span class="p">)</span>

        <span class="c1"># Use provided chunks or create new ones</span>
        <span class="k">if</span> <span class="n">chunks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">chunks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_text</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

        <span class="c1"># Generate summaries for each chunk</span>
        <span class="n">chunk_summaries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">summarize_chunks</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span>

        <span class="c1"># Combine summaries</span>
        <span class="n">combined_summary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_combined_summary</span><span class="p">(</span><span class="n">chunk_summaries</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">combined_summary</span></div>


<div class="viewcode-block" id="GraphExtractor.clear_summary_cache">
<a class="viewcode-back" href="../../../autoapi/owlapy/agen_kg/graph_extractor/index.html#owlapy.agen_kg.graph_extractor.GraphExtractor.clear_summary_cache">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">clear_summary_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Clear the chunk summary cache.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_chunk_summary_cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">: INFO :: Cleared summary cache&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="GraphExtractor.configure_cache">
<a class="viewcode-back" href="../../../autoapi/owlapy/agen_kg/graph_extractor/index.html#owlapy.agen_kg.graph_extractor.GraphExtractor.configure_cache">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">configure_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_cache_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Configure summary cache settings.</span>

<span class="sd">        Args:</span>
<span class="sd">            max_cache_size: Maximum number of summaries to cache (default: 1000).</span>
<span class="sd">                           Set to 0 to disable caching.</span>

<span class="sd">        Example:</span>
<span class="sd">            # Increase cache size for large batch processing</span>
<span class="sd">            extractor.configure_cache(max_cache_size=5000)</span>

<span class="sd">            # Disable caching to minimize memory usage</span>
<span class="sd">            extractor.configure_cache(max_cache_size=0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">max_cache_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_max_cache_size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_cache_size</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">: INFO :: Cache size limit set to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_max_cache_size</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Clear cache if new size is smaller than current cache size</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_chunk_summary_cache</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_cache_size</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">clear_summary_cache</span><span class="p">()</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_merge_entity_lists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entity_lists</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">chunk_summaries</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                            <span class="n">use_llm_merge</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merge entity lists from multiple chunks, removing duplicates.</span>

<span class="sd">        Supports both simple deduplication and LLM-based semantic merging.</span>

<span class="sd">        Args:</span>
<span class="sd">            entity_lists: List of entity lists from each chunk.</span>
<span class="sd">            chunk_summaries: Optional list of chunk summaries for context-aware merging.</span>
<span class="sd">            use_llm_merge: Whether to use LLM for semantic entity merging. If None, uses</span>
<span class="sd">                self.use_incremental_merging (default: None).</span>

<span class="sd">        Returns:</span>
<span class="sd">            Merged and deduplicated list of entities.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">entity_lists</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="c1"># Simple case: only one chunk</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">entity_lists</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">entity_lists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Use class-level setting if not explicitly specified</span>
        <span class="k">if</span> <span class="n">use_llm_merge</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">use_llm_merge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_incremental_merging</span>

        <span class="c1"># If no summaries provided or LLM merge disabled, use simple deduplication</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">use_llm_merge</span> <span class="ow">or</span> <span class="n">chunk_summaries</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk_summaries</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">entity_lists</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simple_merge_entities</span><span class="p">(</span><span class="n">entity_lists</span><span class="p">)</span>

        <span class="c1"># Use incremental LLM-based merging for better quality</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_incremental_merge_entities</span><span class="p">(</span><span class="n">entity_lists</span><span class="p">,</span> <span class="n">chunk_summaries</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_simple_merge_entities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entity_lists</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Simple deduplication-based entity merging.&quot;&quot;&quot;</span>
        <span class="n">all_entities</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">entities</span> <span class="ow">in</span> <span class="n">entity_lists</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">entity</span> <span class="ow">in</span> <span class="n">entities</span><span class="p">:</span>
                <span class="n">entity_lower</span> <span class="o">=</span> <span class="n">entity</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">entity_lower</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                    <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">entity_lower</span><span class="p">)</span>
                    <span class="n">all_entities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entity</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">all_entities</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_incremental_merge_entities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entity_lists</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">chunk_summaries</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Incrementally merge entities using LLM for semantic deduplication.</span>

<span class="sd">        Uses a divide-and-conquer approach to merge entities pairwise,</span>
<span class="sd">        ensuring cross-chunk duplicates are properly identified.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">entity_lists</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">entity_lists</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">entity_lists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Start with first chunk</span>
        <span class="n">merged_entities</span> <span class="o">=</span> <span class="n">entity_lists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">entity_lists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="n">merged_context</span> <span class="o">=</span> <span class="n">chunk_summaries</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Global mapping to track all entity transformations</span>
        <span class="n">global_mapping</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">entity_lists</span><span class="p">)):</span>
            <span class="c1"># Skip empty entity lists</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">entity_lists</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">: INFO :: Merging entity list </span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">entity_lists</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Skip LLM merge if current merged list is empty</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">merged_entities</span><span class="p">:</span>
                <span class="n">merged_entities</span> <span class="o">=</span> <span class="n">entity_lists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">merged_context</span> <span class="o">=</span> <span class="n">chunk_summaries</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">continue</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity_merger</span><span class="p">(</span>
                    <span class="n">entities_a</span><span class="o">=</span><span class="n">merged_entities</span><span class="p">,</span>
                    <span class="n">entities_b</span><span class="o">=</span><span class="n">entity_lists</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                    <span class="n">context_a</span><span class="o">=</span><span class="n">merged_context</span><span class="p">[:</span><span class="mi">1500</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">merged_context</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1500</span> <span class="k">else</span> <span class="n">merged_context</span><span class="p">,</span>
                    <span class="n">context_b</span><span class="o">=</span><span class="n">chunk_summaries</span><span class="p">[</span><span class="n">i</span><span class="p">][:</span><span class="mi">1500</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk_summaries</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1500</span> <span class="k">else</span> <span class="n">chunk_summaries</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="p">)</span>

                <span class="c1"># Validate result</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s1">&#39;merged_entities&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">result</span><span class="o">.</span><span class="n">merged_entities</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">: WARNING :: LLM returned empty result, using simple merge&quot;</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Empty result from LLM&quot;</span><span class="p">)</span>

                <span class="n">merged_entities</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">merged_entities</span>

                <span class="c1"># Update global mapping with new mappings</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s1">&#39;entity_mapping&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">result</span><span class="o">.</span><span class="n">entity_mapping</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">original</span><span class="p">,</span> <span class="n">canonical</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">entity_mapping</span><span class="p">:</span>
                        <span class="n">global_mapping</span><span class="p">[</span><span class="n">original</span><span class="p">]</span> <span class="o">=</span> <span class="n">canonical</span>

                <span class="c1"># Update context (combine summaries, keeping it bounded)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">merged_context</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk_summaries</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_summary_length</span><span class="p">:</span>
                    <span class="n">merged_context</span> <span class="o">=</span> <span class="n">merged_context</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">chunk_summaries</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Keep most recent context</span>
                    <span class="n">merged_context</span> <span class="o">=</span> <span class="n">chunk_summaries</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">: WARNING :: LLM merge failed, falling back to simple merge: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="c1"># Fallback to simple merge for this iteration</span>
                <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">merged_entities</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">entity</span> <span class="ow">in</span> <span class="n">entity_lists</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">entity</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                        <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">entity</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
                        <span class="n">merged_entities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entity</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span> <span class="ow">and</span> <span class="n">global_mapping</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">: INFO :: Entity merge mappings: </span><span class="si">{</span><span class="n">global_mapping</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">merged_entities</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_merge_triple_lists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">triple_lists</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">tuple</span><span class="p">]],</span> <span class="n">chunk_summaries</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                            <span class="n">use_llm_merge</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">tuple</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merge triple lists from multiple chunks, removing duplicates.</span>

<span class="sd">        Supports both simple deduplication and LLM-based semantic merging.</span>

<span class="sd">        Args:</span>
<span class="sd">            triple_lists: List of triple lists from each chunk.</span>
<span class="sd">            chunk_summaries: Optional list of chunk summaries for context-aware merging.</span>
<span class="sd">            use_llm_merge: Whether to use LLM for semantic triple merging. If None, uses</span>
<span class="sd">                self.use_incremental_merging (default: None).</span>

<span class="sd">        Returns:</span>
<span class="sd">            Merged and deduplicated list of triples.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">triple_lists</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">triple_lists</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">triple_lists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Use class-level setting if not explicitly specified</span>
        <span class="k">if</span> <span class="n">use_llm_merge</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">use_llm_merge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_incremental_merging</span>

        <span class="c1"># If no summaries provided or LLM merge disabled, use simple deduplication</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">use_llm_merge</span> <span class="ow">or</span> <span class="n">chunk_summaries</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk_summaries</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">triple_lists</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simple_merge_triples</span><span class="p">(</span><span class="n">triple_lists</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_incremental_merge_triples</span><span class="p">(</span><span class="n">triple_lists</span><span class="p">,</span> <span class="n">chunk_summaries</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_simple_merge_triples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">triple_lists</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">tuple</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">tuple</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Simple deduplication-based triple merging.&quot;&quot;&quot;</span>
        <span class="n">all_triples</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">triples</span> <span class="ow">in</span> <span class="n">triple_lists</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">triple</span> <span class="ow">in</span> <span class="n">triples</span><span class="p">:</span>
                <span class="c1"># Normalize for comparison</span>
                <span class="n">triple_key</span> <span class="o">=</span> <span class="p">(</span><span class="n">triple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="n">triple</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="n">triple</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">triple_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                    <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">triple_key</span><span class="p">)</span>
                    <span class="n">all_triples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">triple</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">all_triples</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_incremental_merge_triples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">triple_lists</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">tuple</span><span class="p">]],</span> <span class="n">chunk_summaries</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">tuple</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Incrementally merge triples using LLM for semantic deduplication.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">triple_lists</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">triple_lists</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">triple_lists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">merged_triples</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">triple_lists</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">triple_lists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="n">merged_context</span> <span class="o">=</span> <span class="n">chunk_summaries</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">triple_lists</span><span class="p">)):</span>
            <span class="c1"># Skip empty triple lists</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">triple_lists</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">: INFO :: Merging triple list </span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">triple_lists</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Skip LLM merge if current merged list is empty</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">merged_triples</span><span class="p">:</span>
                <span class="n">merged_triples</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">triple_lists</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">merged_context</span> <span class="o">=</span> <span class="n">chunk_summaries</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">continue</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">triple_merger</span><span class="p">(</span>
                    <span class="n">triples_a</span><span class="o">=</span><span class="n">merged_triples</span><span class="p">,</span>
                    <span class="n">triples_b</span><span class="o">=</span><span class="n">triple_lists</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                    <span class="n">context_a</span><span class="o">=</span><span class="n">merged_context</span><span class="p">[:</span><span class="mi">1500</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">merged_context</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1500</span> <span class="k">else</span> <span class="n">merged_context</span><span class="p">,</span>
                    <span class="n">context_b</span><span class="o">=</span><span class="n">chunk_summaries</span><span class="p">[</span><span class="n">i</span><span class="p">][:</span><span class="mi">1500</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk_summaries</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1500</span> <span class="k">else</span> <span class="n">chunk_summaries</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="p">)</span>

                <span class="c1"># Validate result</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s1">&#39;merged_triples&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">result</span><span class="o">.</span><span class="n">merged_triples</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">: WARNING :: LLM returned empty result, using simple merge&quot;</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Empty result from LLM&quot;</span><span class="p">)</span>

                <span class="n">merged_triples</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">merged_triples</span>

                <span class="c1"># Update context</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">merged_context</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk_summaries</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_summary_length</span><span class="p">:</span>
                    <span class="n">merged_context</span> <span class="o">=</span> <span class="n">merged_context</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">chunk_summaries</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">merged_context</span> <span class="o">=</span> <span class="n">chunk_summaries</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">: WARNING :: LLM triple merge failed, falling back to simple merge: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="c1"># Fallback to simple merge</span>
                <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">((</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">merged_triples</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">triple</span> <span class="ow">in</span> <span class="n">triple_lists</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">triple_key</span> <span class="o">=</span> <span class="p">(</span><span class="n">triple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="n">triple</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="n">triple</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
                    <span class="k">if</span> <span class="n">triple_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                        <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">triple_key</span><span class="p">)</span>
                        <span class="n">merged_triples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">triple</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">merged_triples</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_merge_type_assertions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assertion_lists</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">tuple</span><span class="p">]],</span> <span class="n">chunk_summaries</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                               <span class="n">use_llm_merge</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">tuple</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merge type assertion lists from multiple chunks.</span>

<span class="sd">        For duplicate entity-type assignments, resolves conflicts intelligently.</span>

<span class="sd">        Args:</span>
<span class="sd">            assertion_lists: List of type assertion lists from each chunk.</span>
<span class="sd">            chunk_summaries: Optional list of chunk summaries for context-aware merging.</span>
<span class="sd">            use_llm_merge: Whether to use LLM for semantic type merging. If None, uses</span>
<span class="sd">                self.use_incremental_merging (default: None).</span>

<span class="sd">        Returns:</span>
<span class="sd">            Merged type assertions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">assertion_lists</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">assertion_lists</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">assertion_lists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Use class-level setting if not explicitly specified</span>
        <span class="k">if</span> <span class="n">use_llm_merge</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">use_llm_merge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_incremental_merging</span>

        <span class="c1"># If no summaries provided or LLM merge disabled, use simple merging</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">use_llm_merge</span> <span class="ow">or</span> <span class="n">chunk_summaries</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk_summaries</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">assertion_lists</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simple_merge_type_assertions</span><span class="p">(</span><span class="n">assertion_lists</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_incremental_merge_type_assertions</span><span class="p">(</span><span class="n">assertion_lists</span><span class="p">,</span> <span class="n">chunk_summaries</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_simple_merge_type_assertions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assertion_lists</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">tuple</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">tuple</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Simple type assertion merging that keeps first seen type for each entity.&quot;&quot;&quot;</span>
        <span class="n">entity_types</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># entity -&gt; type (keep first seen)</span>
        <span class="k">for</span> <span class="n">assertions</span> <span class="ow">in</span> <span class="n">assertion_lists</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">entity</span><span class="p">,</span> <span class="n">entity_type</span> <span class="ow">in</span> <span class="n">assertions</span><span class="p">:</span>
                <span class="n">entity_lower</span> <span class="o">=</span> <span class="n">entity</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">entity_lower</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">entity_types</span><span class="p">:</span>
                    <span class="n">entity_types</span><span class="p">[</span><span class="n">entity_lower</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">entity</span><span class="p">,</span> <span class="n">entity_type</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">entity_types</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_incremental_merge_type_assertions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assertion_lists</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">tuple</span><span class="p">]],</span> <span class="n">chunk_summaries</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> \
    <span class="n">List</span><span class="p">[</span><span class="nb">tuple</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Incrementally merge type assertions using LLM to resolve conflicts.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">assertion_lists</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">assertion_lists</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">assertion_lists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">merged_types</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">assertion_lists</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">assertion_lists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="n">merged_context</span> <span class="o">=</span> <span class="n">chunk_summaries</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">assertion_lists</span><span class="p">)):</span>
            <span class="c1"># Skip empty assertion lists</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">assertion_lists</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">: INFO :: Merging type assertions </span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">assertion_lists</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Skip LLM merge if current merged list is empty</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">merged_types</span><span class="p">:</span>
                <span class="n">merged_types</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">assertion_lists</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">merged_context</span> <span class="o">=</span> <span class="n">chunk_summaries</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">continue</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_merger</span><span class="p">(</span>
                    <span class="n">types_a</span><span class="o">=</span><span class="n">merged_types</span><span class="p">,</span>
                    <span class="n">types_b</span><span class="o">=</span><span class="n">assertion_lists</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                    <span class="n">context_a</span><span class="o">=</span><span class="n">merged_context</span><span class="p">[:</span><span class="mi">1500</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">merged_context</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1500</span> <span class="k">else</span> <span class="n">merged_context</span><span class="p">,</span>
                    <span class="n">context_b</span><span class="o">=</span><span class="n">chunk_summaries</span><span class="p">[</span><span class="n">i</span><span class="p">][:</span><span class="mi">1500</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk_summaries</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1500</span> <span class="k">else</span> <span class="n">chunk_summaries</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="p">)</span>

                <span class="c1"># Validate result</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s1">&#39;merged_types&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">result</span><span class="o">.</span><span class="n">merged_types</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">: WARNING :: LLM returned empty result, using simple merge&quot;</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Empty result from LLM&quot;</span><span class="p">)</span>

                <span class="n">merged_types</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">merged_types</span>

                <span class="c1"># Update context</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">merged_context</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk_summaries</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_summary_length</span><span class="p">:</span>
                    <span class="n">merged_context</span> <span class="o">=</span> <span class="n">merged_context</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">chunk_summaries</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">merged_context</span> <span class="o">=</span> <span class="n">chunk_summaries</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">: WARNING :: LLM type merge failed, falling back to simple merge: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="c1"># Fallback to simple merge</span>
                <span class="n">existing_entities</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">merged_types</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">entity</span><span class="p">,</span> <span class="n">entity_type</span> <span class="ow">in</span> <span class="n">assertion_lists</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">entity</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">existing_entities</span><span class="p">:</span>
                        <span class="n">existing_entities</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">entity</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
                        <span class="n">merged_types</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">entity</span><span class="p">,</span> <span class="n">entity_type</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">merged_types</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_merge_literal_lists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">literal_lists</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merge literal value lists from multiple chunks, removing duplicates.</span>

<span class="sd">        Args:</span>
<span class="sd">            literal_lists: List of literal lists from each chunk.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Merged and deduplicated list of literals.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">all_literals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">literals</span> <span class="ow">in</span> <span class="n">literal_lists</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">literal</span> <span class="ow">in</span> <span class="n">literals</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">literal</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                    <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">literal</span><span class="p">)</span>
                    <span class="n">all_literals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">literal</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">all_literals</span>

<div class="viewcode-block" id="GraphExtractor.filter_entities">
<a class="viewcode-back" href="../../../autoapi/owlapy/agen_kg/graph_extractor/index.html#owlapy.agen_kg.graph_extractor.GraphExtractor.filter_entities">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">filter_entities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entities</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">use_summary</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deduplicate entities by removing redundant near-duplicates.</span>

<span class="sd">        For large texts, automatically uses summarization to provide context</span>
<span class="sd">        that fits within token limits.</span>

<span class="sd">        Args:</span>
<span class="sd">            entities: List of extracted entities.</span>
<span class="sd">            text: Original text context (or pre-computed summary).</span>
<span class="sd">            use_summary: Whether to use summary-based deduplication.</span>
<span class="sd">                - None (default): Auto-detect based on text size.</span>
<span class="sd">                - True: Force summary-based deduplication.</span>
<span class="sd">                - False: Use direct text (may fail for large texts).</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dictionary mapping original entity names to their canonical names.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">entities</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="c1"># Determine whether to use summarization</span>
        <span class="k">if</span> <span class="n">use_summary</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">use_summary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">should_use_summarization</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">use_summary</span><span class="p">:</span>
            <span class="c1"># Get or create summary for deduplication context</span>
            <span class="n">clustering_context</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_clustering_context</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">: INFO :: Using summary (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">clustering_context</span><span class="p">)</span><span class="si">}</span><span class="s2"> chars) for entity deduplication&quot;</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity_deduplicator_with_summary</span><span class="p">(</span><span class="n">entities</span><span class="o">=</span><span class="n">entities</span><span class="p">,</span> <span class="n">summary</span><span class="o">=</span><span class="n">clustering_context</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Use direct text (truncated if necessary)</span>
            <span class="n">context</span> <span class="o">=</span> <span class="n">text</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">max_summary_length</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_summary_length</span> <span class="k">else</span> <span class="n">text</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity_deduplicator</span><span class="p">(</span><span class="n">entities</span><span class="o">=</span><span class="n">entities</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="n">context</span><span class="p">)</span>

        <span class="c1"># Get the filtered entities list</span>
        <span class="n">filtered_entities</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">filtered_entities</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span><span class="p">:</span>
            <span class="n">merged_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">entities</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">filtered_entities</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">merged_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">: INFO :: Filtered out </span><span class="si">{</span><span class="n">merged_count</span><span class="si">}</span><span class="s2"> redundant entities&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">filtered_entities</span></div>


<div class="viewcode-block" id="GraphExtractor.cluster_types">
<a class="viewcode-back" href="../../../autoapi/owlapy/agen_kg/graph_extractor/index.html#owlapy.agen_kg.graph_extractor.GraphExtractor.cluster_types">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">cluster_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">types</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">use_summary</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cluster entity types to identify and merge duplicates.</span>

<span class="sd">        For large texts, automatically uses summarization to provide context</span>
<span class="sd">        that fits within token limits.</span>

<span class="sd">        Args:</span>
<span class="sd">            types: List of extracted entity types.</span>
<span class="sd">            text: Original text context (or pre-computed summary).</span>
<span class="sd">            use_summary: Whether to use summary-based clustering.</span>
<span class="sd">                - None (default): Auto-detect based on text size.</span>
<span class="sd">                - True: Force summary-based clustering.</span>
<span class="sd">                - False: Use direct text (may fail for large texts).</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dictionary mapping original type names to their canonical names.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">types</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{}</span>

        <span class="c1"># Determine whether to use summarization</span>
        <span class="k">if</span> <span class="n">use_summary</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">use_summary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">should_use_summarization</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">use_summary</span><span class="p">:</span>
            <span class="n">clustering_context</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_clustering_context</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">: INFO :: Using summary (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">clustering_context</span><span class="p">)</span><span class="si">}</span><span class="s2"> chars) for type clustering&quot;</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_clusterer_with_summary</span><span class="p">(</span><span class="n">types</span><span class="o">=</span><span class="n">types</span><span class="p">,</span> <span class="n">summary</span><span class="o">=</span><span class="n">clustering_context</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">context</span> <span class="o">=</span> <span class="n">text</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">max_summary_length</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_summary_length</span> <span class="k">else</span> <span class="n">text</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_clusterer</span><span class="p">(</span><span class="n">types</span><span class="o">=</span><span class="n">types</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="n">context</span><span class="p">)</span>

        <span class="n">type_mapping</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">canonical_name</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">clusters</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">type_name</span> <span class="ow">in</span> <span class="n">cluster</span><span class="p">:</span>
                <span class="n">type_mapping</span><span class="p">[</span><span class="n">type_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">canonical_name</span>

        <span class="c1"># Add types that weren&#39;t clustered</span>
        <span class="k">for</span> <span class="n">type_name</span> <span class="ow">in</span> <span class="n">types</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">type_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">type_mapping</span><span class="p">:</span>
                <span class="n">type_mapping</span><span class="p">[</span><span class="n">type_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">type_name</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span><span class="p">:</span>
            <span class="n">merged_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">types</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">type_mapping</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
            <span class="k">if</span> <span class="n">merged_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">: INFO :: Merged </span><span class="si">{</span><span class="n">merged_count</span><span class="si">}</span><span class="s2"> duplicate types&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">type_mapping</span></div>


<div class="viewcode-block" id="GraphExtractor.cluster_relations">
<a class="viewcode-back" href="../../../autoapi/owlapy/agen_kg/graph_extractor/index.html#owlapy.agen_kg.graph_extractor.GraphExtractor.cluster_relations">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">cluster_relations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">relations</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">use_summary</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cluster relations to identify and merge duplicates.</span>

<span class="sd">        For large texts, automatically uses summarization to provide context</span>
<span class="sd">        that fits within token limits.</span>

<span class="sd">        Args:</span>
<span class="sd">            relations: List of extracted relations.</span>
<span class="sd">            text: Original text context (or pre-computed summary).</span>
<span class="sd">            use_summary: Whether to use summary-based clustering.</span>
<span class="sd">                - None (default): Auto-detect based on text size.</span>
<span class="sd">                - True: Force summary-based clustering.</span>
<span class="sd">                - False: Use direct text (may fail for large texts).</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dictionary mapping original relation names to their canonical names.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">relations</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{}</span>

        <span class="c1"># Determine whether to use summarization</span>
        <span class="k">if</span> <span class="n">use_summary</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">use_summary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">should_use_summarization</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">use_summary</span><span class="p">:</span>
            <span class="n">clustering_context</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_clustering_context</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">: INFO :: Using summary (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">clustering_context</span><span class="p">)</span><span class="si">}</span><span class="s2"> chars) for relation clustering&quot;</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relation_clusterer_with_summary</span><span class="p">(</span><span class="n">relations</span><span class="o">=</span><span class="n">relations</span><span class="p">,</span> <span class="n">summary</span><span class="o">=</span><span class="n">clustering_context</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">context</span> <span class="o">=</span> <span class="n">text</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">max_summary_length</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_summary_length</span> <span class="k">else</span> <span class="n">text</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relation_clusterer</span><span class="p">(</span><span class="n">relations</span><span class="o">=</span><span class="n">relations</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="n">context</span><span class="p">)</span>

        <span class="n">relation_mapping</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">canonical_name</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">clusters</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">relation</span> <span class="ow">in</span> <span class="n">cluster</span><span class="p">:</span>
                <span class="n">relation_mapping</span><span class="p">[</span><span class="n">relation</span><span class="p">]</span> <span class="o">=</span> <span class="n">canonical_name</span>

        <span class="c1"># Add relations that weren&#39;t clustered</span>
        <span class="k">for</span> <span class="n">relation</span> <span class="ow">in</span> <span class="n">relations</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">relation</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">relation_mapping</span><span class="p">:</span>
                <span class="n">relation_mapping</span><span class="p">[</span><span class="n">relation</span><span class="p">]</span> <span class="o">=</span> <span class="n">relation</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span><span class="p">:</span>
            <span class="n">merged_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">relations</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">relation_mapping</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
            <span class="k">if</span> <span class="n">merged_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">: INFO :: Merged </span><span class="si">{</span><span class="n">merged_count</span><span class="si">}</span><span class="s2"> duplicate relations&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">relation_mapping</span></div>


<div class="viewcode-block" id="GraphExtractor.check_coherence">
<a class="viewcode-back" href="../../../autoapi/owlapy/agen_kg/graph_extractor/index.html#owlapy.agen_kg.graph_extractor.GraphExtractor.check_coherence">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">check_coherence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">triples</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">tuple</span><span class="p">],</span> <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">task_instructions</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
                        <span class="n">threshold</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">use_summary</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">tuple</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check coherence of extracted triples and filter out low-quality ones.</span>

<span class="sd">        For large texts, automatically uses summarization to provide context</span>
<span class="sd">        that fits within token limits.</span>

<span class="sd">        Args:</span>
<span class="sd">            triples: List of extracted triples.</span>
<span class="sd">            text: Original text context (or pre-computed summary).</span>
<span class="sd">            task_instructions: Optional instructions to guide coherence checking.</span>
<span class="sd">            batch_size: Number of triples to check per batch.</span>
<span class="sd">            threshold: Minimum coherence score (1-5) to keep a triple.</span>
<span class="sd">            use_summary: Whether to use summary for coherence checking.</span>
<span class="sd">                - None (default): Auto-detect based on text size.</span>
<span class="sd">                - True: Force summary-based checking.</span>
<span class="sd">                - False: Use direct text (may fail for large texts).</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of coherent triples that passed the threshold.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">triples</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="c1"># Determine context to use</span>
        <span class="k">if</span> <span class="n">use_summary</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">use_summary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">should_use_summarization</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">use_summary</span><span class="p">:</span>
            <span class="n">context</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_clustering_context</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">: INFO :: Using summary (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">context</span><span class="p">)</span><span class="si">}</span><span class="s2"> chars) for coherence checking&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">context</span> <span class="o">=</span> <span class="n">text</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">max_summary_length</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_summary_length</span> <span class="k">else</span> <span class="n">text</span>

        <span class="n">coherent_triples</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Process triples in batches</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">triples</span><span class="p">),</span> <span class="n">batch_size</span><span class="p">):</span>
            <span class="n">batch</span> <span class="o">=</span> <span class="n">triples</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">batch_size</span><span class="p">]</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coherence_checker</span><span class="p">(</span><span class="n">triples</span><span class="o">=</span><span class="n">batch</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="n">context</span><span class="p">,</span> <span class="n">task_instructions</span><span class="o">=</span><span class="n">task_instructions</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">triple</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="n">explanation</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">coherence_scores</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">score</span> <span class="o">&gt;=</span> <span class="n">threshold</span><span class="p">:</span>
                    <span class="n">coherent_triples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">triple</span><span class="p">)</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">: INFO :: Filtered out triple </span><span class="si">{</span><span class="n">triple</span><span class="si">}</span><span class="s2"> (score: </span><span class="si">{</span><span class="n">score</span><span class="si">}</span><span class="s2">/5): </span><span class="si">{</span><span class="n">explanation</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span><span class="p">:</span>
            <span class="n">filtered_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">triples</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">coherent_triples</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">filtered_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">: INFO :: Filtered out </span><span class="si">{</span><span class="n">filtered_count</span><span class="si">}</span><span class="s2"> low-coherence triples&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">coherent_triples</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_extract_entities_from_chunks</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">chunks</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
            <span class="n">examples_for_entity_extraction</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">extractor_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">use_llm_merge</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">task_instructions</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract entities from multiple text chunks and merge results.</span>
<span class="sd">        Generic method that works for all extractor subclasses.</span>

<span class="sd">        Args:</span>
<span class="sd">            chunks: List of text chunks.</span>
<span class="sd">            examples_for_entity_extraction: Few-shot examples.</span>
<span class="sd">            extractor_name: Name of the extractor (for logging). If None, uses class name.</span>
<span class="sd">            use_llm_merge: Whether to use LLM-based merging for better quality. If None, uses</span>
<span class="sd">                self.use_incremental_merging (default: None).</span>
<span class="sd">            task_instructions: Further instructions in accordance with the user&#39;s query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple of (merged_entities, chunk_summaries) where chunk_summaries can be used</span>
<span class="sd">            for subsequent operations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;entity_extractor&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> must define &#39;entity_extractor&#39;&quot;</span><span class="p">)</span>

        <span class="n">extractor_name</span> <span class="o">=</span> <span class="n">extractor_name</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">all_entity_lists</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">chunk_summaries</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Use class-level setting if not explicitly specified</span>
        <span class="k">if</span> <span class="n">use_llm_merge</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">use_llm_merge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_incremental_merging</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">chunks</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">extractor_name</span><span class="si">}</span><span class="s2">: INFO :: Extracting entities from chunk </span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entity_extractor</span><span class="p">(</span>
                    <span class="n">text</span><span class="o">=</span><span class="n">chunk</span><span class="p">,</span>
                    <span class="n">few_shot_examples</span><span class="o">=</span><span class="n">examples_for_entity_extraction</span><span class="p">,</span>
                    <span class="n">task_instructions</span><span class="o">=</span><span class="n">task_instructions</span>
                <span class="p">)</span>
                <span class="n">chunk_entities</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">entities</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s1">&#39;entities&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">result</span><span class="o">.</span><span class="n">entities</span> <span class="k">else</span> <span class="p">[]</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">extractor_name</span><span class="si">}</span><span class="s2">: WARNING :: Failed to extract entities from chunk </span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">chunk_entities</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="n">all_entity_lists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chunk_entities</span><span class="p">)</span>

            <span class="c1"># Generate summary for this chunk (for later use in merging/clustering)</span>
            <span class="k">if</span> <span class="n">use_llm_merge</span><span class="p">:</span>
                <span class="n">summary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">summarize_chunk</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
                <span class="n">chunk_summaries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">summary</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">extractor_name</span><span class="si">}</span><span class="s2">: INFO :: Found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">chunk_entities</span><span class="p">)</span><span class="si">}</span><span class="s2"> entities in chunk </span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Merge entities from all chunks</span>
        <span class="n">merged_entities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_merge_entity_lists</span><span class="p">(</span><span class="n">all_entity_lists</span><span class="p">,</span> <span class="n">chunk_summaries</span><span class="p">,</span> <span class="n">use_llm_merge</span><span class="o">=</span><span class="n">use_llm_merge</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">use_llm_merge</span><span class="p">:</span>
            <span class="n">chunk_summaries</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Return empty if not generated</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">extractor_name</span><span class="si">}</span><span class="s2">: INFO :: Total merged entities: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">merged_entities</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">merged_entities</span><span class="p">,</span> <span class="n">chunk_summaries</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_extract_triples_from_chunks</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">chunks</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
            <span class="n">entities</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
            <span class="n">examples_for_triples_extraction</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">extractor_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">chunk_summaries</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">use_llm_merge</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">task_instructions</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">tuple</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract triples from multiple text chunks and merge results.</span>
<span class="sd">        Generic method that works for all extractor subclasses.</span>

<span class="sd">        Args:</span>
<span class="sd">            chunks: List of text chunks.</span>
<span class="sd">            entities: List of entities to use for extraction.</span>
<span class="sd">            examples_for_triples_extraction: Few-shot examples.</span>
<span class="sd">            extractor_name: Name of the extractor (for logging). If None, uses class name.</span>
<span class="sd">            chunk_summaries: Optional pre-computed chunk summaries for merging context.</span>
<span class="sd">            use_llm_merge: Whether to use LLM-based merging for better quality. If None, uses</span>
<span class="sd">                self.use_incremental_merging (default: None).</span>
<span class="sd">            task_instructions: Further instructions in accordance with the user&#39;s query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Merged list of triples from all chunks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;triples_extractor&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> must define &#39;triples_extractor&#39;&quot;</span><span class="p">)</span>

        <span class="n">extractor_name</span> <span class="o">=</span> <span class="n">extractor_name</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">all_triple_lists</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Use class-level setting if not explicitly specified</span>
        <span class="k">if</span> <span class="n">use_llm_merge</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">use_llm_merge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_incremental_merging</span>

        <span class="c1"># Generate summaries if not provided and LLM merge is enabled</span>
        <span class="k">if</span> <span class="n">use_llm_merge</span> <span class="ow">and</span> <span class="n">chunk_summaries</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">chunk_summaries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">summarize_chunks</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">chunks</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">extractor_name</span><span class="si">}</span><span class="s2">: INFO :: Extracting triples from chunk </span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">triples_extractor</span><span class="p">(</span>
                    <span class="n">text</span><span class="o">=</span><span class="n">chunk</span><span class="p">,</span>
                    <span class="n">entities</span><span class="o">=</span><span class="n">entities</span><span class="p">,</span>
                    <span class="n">few_shot_examples</span><span class="o">=</span><span class="n">examples_for_triples_extraction</span><span class="p">,</span>
                    <span class="n">task_instructions</span><span class="o">=</span><span class="n">task_instructions</span>
                <span class="p">)</span>
                <span class="n">chunk_triples</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">triples</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s1">&#39;triples&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">result</span><span class="o">.</span><span class="n">triples</span> <span class="k">else</span> <span class="p">[]</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">extractor_name</span><span class="si">}</span><span class="s2">: WARNING :: Failed to extract triples from chunk </span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">chunk_triples</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="n">all_triple_lists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chunk_triples</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">extractor_name</span><span class="si">}</span><span class="s2">: INFO :: Found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">chunk_triples</span><span class="p">)</span><span class="si">}</span><span class="s2"> triples in chunk </span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Merge triples from all chunks</span>
        <span class="n">merged_triples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_merge_triple_lists</span><span class="p">(</span><span class="n">all_triple_lists</span><span class="p">,</span> <span class="n">chunk_summaries</span><span class="p">,</span> <span class="n">use_llm_merge</span><span class="o">=</span><span class="n">use_llm_merge</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">extractor_name</span><span class="si">}</span><span class="s2">: INFO :: Total merged triples: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">merged_triples</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">merged_triples</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_extract_types_from_chunks</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">chunks</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
            <span class="n">entities</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
            <span class="n">entity_types</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
            <span class="n">generate_types</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
            <span class="n">examples_for_type_assertion</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">examples_for_type_generation</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">extractor_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">chunk_summaries</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">use_llm_merge</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">task_instructions_assertion</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">task_instructions_generation</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">tuple</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract type assertions from multiple text chunks and merge results.</span>
<span class="sd">        Generic method that works for all extractor subclasses.</span>

<span class="sd">        Args:</span>
<span class="sd">            chunks: List of text chunks.</span>
<span class="sd">            entities: List of entities.</span>
<span class="sd">            entity_types: List of predefined types (if not generating).</span>
<span class="sd">            generate_types: Whether to generate types.</span>
<span class="sd">            examples_for_type_assertion: Few-shot examples for assertion.</span>
<span class="sd">            examples_for_type_generation: Few-shot examples for generation.</span>
<span class="sd">            extractor_name: Name of the extractor (for logging). If None, uses class name.</span>
<span class="sd">            chunk_summaries: Optional pre-computed chunk summaries for merging context.</span>
<span class="sd">            use_llm_merge: Whether to use LLM-based merging for better quality. If None, uses</span>
<span class="sd">                self.use_incremental_merging (default: None).</span>
<span class="sd">            task_instructions_assertion: Further type assertion instructions in accordance with the user&#39;s query.</span>
<span class="sd">            task_instructions_generation: Further type generation instructions in accordance with the user&#39;s query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Merged list of type assertions from all chunks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;type_asserter&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;type_generator&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> must define &#39;type_asserter&#39; and &#39;type_generator&#39;&quot;</span><span class="p">)</span>

        <span class="n">extractor_name</span> <span class="o">=</span> <span class="n">extractor_name</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">all_assertion_lists</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Use class-level setting if not explicitly specified</span>
        <span class="k">if</span> <span class="n">use_llm_merge</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">use_llm_merge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_incremental_merging</span>

        <span class="c1"># Generate summaries if not provided and LLM merge is enabled</span>
        <span class="k">if</span> <span class="n">use_llm_merge</span> <span class="ow">and</span> <span class="n">chunk_summaries</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">chunk_summaries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">summarize_chunks</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">chunks</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">extractor_name</span><span class="si">}</span><span class="s2">: INFO :: Extracting types from chunk </span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">entity_types</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">generate_types</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_asserter</span><span class="p">(</span>
                        <span class="n">text</span><span class="o">=</span><span class="n">chunk</span><span class="p">,</span>
                        <span class="n">entities</span><span class="o">=</span><span class="n">entities</span><span class="p">,</span>
                        <span class="n">entity_types</span><span class="o">=</span><span class="n">entity_types</span><span class="p">,</span>
                        <span class="n">task_instructions</span> <span class="o">=</span> <span class="n">task_instructions_assertion</span><span class="p">,</span>
                        <span class="n">few_shot_examples</span><span class="o">=</span><span class="n">examples_for_type_assertion</span>
                    <span class="p">)</span>
                    <span class="n">chunk_assertions</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">pairs</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s1">&#39;pairs&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">result</span><span class="o">.</span><span class="n">pairs</span> <span class="k">else</span> <span class="p">[]</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># generate_types</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_generator</span><span class="p">(</span>
                        <span class="n">text</span><span class="o">=</span><span class="n">chunk</span><span class="p">,</span>
                        <span class="n">entities</span><span class="o">=</span><span class="n">entities</span><span class="p">,</span>
                        <span class="n">task_instructions</span> <span class="o">=</span> <span class="n">task_instructions_generation</span><span class="p">,</span>
                        <span class="n">few_shot_examples</span><span class="o">=</span><span class="n">examples_for_type_generation</span>
                    <span class="p">)</span>
                    <span class="n">chunk_assertions</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">pairs</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s1">&#39;pairs&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">result</span><span class="o">.</span><span class="n">pairs</span> <span class="k">else</span> <span class="p">[]</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">extractor_name</span><span class="si">}</span><span class="s2">: WARNING :: Failed to extract types from chunk </span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">chunk_assertions</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="n">all_assertion_lists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chunk_assertions</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">extractor_name</span><span class="si">}</span><span class="s2">: INFO :: Found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">chunk_assertions</span><span class="p">)</span><span class="si">}</span><span class="s2"> type assertions in chunk </span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Merge type assertions from all chunks</span>
        <span class="n">merged_assertions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_merge_type_assertions</span><span class="p">(</span><span class="n">all_assertion_lists</span><span class="p">,</span> <span class="n">chunk_summaries</span><span class="p">,</span> <span class="n">use_llm_merge</span><span class="o">=</span><span class="n">use_llm_merge</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">extractor_name</span><span class="si">}</span><span class="s2">: INFO :: Total merged type assertions: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">merged_assertions</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">merged_assertions</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_extract_literals_from_chunks</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">chunks</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
            <span class="n">examples_for_literal_extraction</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">extractor_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">task_instructions</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract literals from multiple text chunks and merge results.</span>
<span class="sd">        Generic method that works for all extractor subclasses.</span>

<span class="sd">        Args:</span>
<span class="sd">            chunks: List of text chunks.</span>
<span class="sd">            examples_for_literal_extraction: Few-shot examples.</span>
<span class="sd">            extractor_name: Name of the extractor (for logging). If None, uses class name.</span>
<span class="sd">            task_instructions: Further instructions in accordance with the user&#39;s query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Merged list of literals from all chunks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;literal_extractor&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> must define &#39;literal_extractor&#39;&quot;</span><span class="p">)</span>

        <span class="n">extractor_name</span> <span class="o">=</span> <span class="n">extractor_name</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">all_literal_lists</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">chunks</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">extractor_name</span><span class="si">}</span><span class="s2">: INFO :: Extracting literals from chunk </span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">literal_extractor</span><span class="p">(</span>
                    <span class="n">text</span><span class="o">=</span><span class="n">chunk</span><span class="p">,</span>
                    <span class="n">task_instructions</span><span class="o">=</span><span class="n">task_instructions</span><span class="p">,</span>
                    <span class="n">few_shot_examples</span><span class="o">=</span><span class="n">examples_for_literal_extraction</span>
                <span class="p">)</span>
                <span class="n">chunk_literals</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">l_values</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s1">&#39;l_values&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">result</span><span class="o">.</span><span class="n">l_values</span> <span class="k">else</span> <span class="p">[]</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">extractor_name</span><span class="si">}</span><span class="s2">: WARNING :: Failed to extract literals from chunk </span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">chunk_literals</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="n">all_literal_lists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chunk_literals</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">extractor_name</span><span class="si">}</span><span class="s2">: INFO :: Found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">chunk_literals</span><span class="p">)</span><span class="si">}</span><span class="s2"> literals in chunk </span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Merge literals from all chunks</span>
        <span class="n">merged_literals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_merge_literal_lists</span><span class="p">(</span><span class="n">all_literal_lists</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">extractor_name</span><span class="si">}</span><span class="s2">: INFO :: Total merged literals: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">merged_literals</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">merged_literals</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_extract_spl_triples_from_chunks</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">chunks</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
            <span class="n">entities</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
            <span class="n">literals</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
            <span class="n">examples_for_spl_triples_extraction</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">extractor_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">task_instructions</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">tuple</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract SPL triples from multiple text chunks and merge results.</span>
<span class="sd">        Generic method that works for all extractor subclasses.</span>

<span class="sd">        Args:</span>
<span class="sd">            chunks: List of text chunks.</span>
<span class="sd">            entities: List of entities.</span>
<span class="sd">            literals: List of numeric literals.</span>
<span class="sd">            examples_for_spl_triples_extraction: Few-shot examples.</span>
<span class="sd">            extractor_name: Name of the extractor (for logging). If None, uses class name.</span>
<span class="sd">            task_instructions: Further instructions in accordance with the user&#39;s query.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Merged list of SPL triples from all chunks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;spl_triples_extractor&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> must define &#39;spl_triples_extractor&#39;&quot;</span><span class="p">)</span>

        <span class="n">extractor_name</span> <span class="o">=</span> <span class="n">extractor_name</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">all_triple_lists</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">chunks</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">extractor_name</span><span class="si">}</span><span class="s2">: INFO :: Extracting SPL triples from chunk </span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spl_triples_extractor</span><span class="p">(</span>
                    <span class="n">text</span><span class="o">=</span><span class="n">chunk</span><span class="p">,</span>
                    <span class="n">entities</span><span class="o">=</span><span class="n">entities</span><span class="p">,</span>
                    <span class="n">numeric_literals</span><span class="o">=</span><span class="n">literals</span><span class="p">,</span>
                    <span class="n">task_instructions</span><span class="o">=</span> <span class="n">task_instructions</span><span class="p">,</span>
                    <span class="n">few_shot_examples</span><span class="o">=</span><span class="n">examples_for_spl_triples_extraction</span>
                <span class="p">)</span>
                <span class="n">chunk_triples</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">triples</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s1">&#39;triples&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">result</span><span class="o">.</span><span class="n">triples</span> <span class="k">else</span> <span class="p">[]</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">extractor_name</span><span class="si">}</span><span class="s2">: WARNING :: Failed to extract SPL triples from chunk </span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">chunk_triples</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="n">all_triple_lists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chunk_triples</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">extractor_name</span><span class="si">}</span><span class="s2">: INFO :: Found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">chunk_triples</span><span class="p">)</span><span class="si">}</span><span class="s2"> SPL triples in chunk </span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Merge SPL triples from all chunks</span>
        <span class="n">merged_triples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_merge_triple_lists</span><span class="p">(</span><span class="n">all_triple_lists</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logging</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">extractor_name</span><span class="si">}</span><span class="s2">: INFO :: Total merged SPL triples: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">merged_triples</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">merged_triples</span>

<div class="viewcode-block" id="GraphExtractor.get_corresponding_literal">
<a class="viewcode-back" href="../../../autoapi/owlapy/agen_kg/graph_extractor/index.html#owlapy.agen_kg.graph_extractor.GraphExtractor.get_corresponding_literal">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_corresponding_literal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">literal_value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">OWLLiteral</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a string literal value to an OWLLiteral with the appropriate datatype.&quot;&quot;&quot;</span>

        <span class="n">value</span> <span class="o">=</span> <span class="n">literal_value</span>
        <span class="n">literal</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Try DateTime first (most specific date type)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">parsed_datetime</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">fromisoformat</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
            <span class="n">literal</span> <span class="o">=</span> <span class="n">OWLLiteral</span><span class="p">(</span><span class="n">parsed_datetime</span><span class="p">)</span>  <span class="c1"># OWLLiteral will auto-detect datetime type</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
            <span class="k">pass</span>

        <span class="c1"># Try Date (without time)</span>
        <span class="k">if</span> <span class="n">literal</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Check if it looks like a date format (YYYY-MM-DD)</span>
                <span class="n">parsed_date</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">()</span>
                <span class="n">literal</span> <span class="o">=</span> <span class="n">OWLLiteral</span><span class="p">(</span><span class="n">parsed_date</span><span class="p">)</span>  <span class="c1"># OWLLiteral will auto-detect date type</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
                <span class="k">pass</span>

        <span class="c1"># Try Boolean</span>
        <span class="k">if</span> <span class="n">literal</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">str_value</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">str_value</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;true&#39;</span><span class="p">,</span> <span class="s1">&#39;false&#39;</span><span class="p">):</span>
                    <span class="n">bool_value</span> <span class="o">=</span> <span class="n">str_value</span> <span class="o">==</span> <span class="s1">&#39;true&#39;</span>
                    <span class="n">literal</span> <span class="o">=</span> <span class="n">OWLLiteral</span><span class="p">(</span><span class="n">bool_value</span><span class="p">)</span>  <span class="c1"># OWLLiteral will auto-detect bool type</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
                <span class="k">pass</span>

        <span class="c1"># Try Integer</span>
        <span class="k">if</span> <span class="n">literal</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Check if it&#39;s an integer (no decimal point or is x.0)</span>
                <span class="n">float_value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">float_value</span><span class="o">.</span><span class="n">is_integer</span><span class="p">():</span>
                    <span class="n">int_value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">float_value</span><span class="p">)</span>
                    <span class="n">literal</span> <span class="o">=</span> <span class="n">OWLLiteral</span><span class="p">(</span><span class="n">int_value</span><span class="p">)</span>  <span class="c1"># OWLLiteral will auto-detect int type</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># It&#39;s a float with decimal places</span>
                    <span class="n">literal</span> <span class="o">=</span> <span class="n">OWLLiteral</span><span class="p">(</span><span class="n">float_value</span><span class="p">)</span>  <span class="c1"># OWLLiteral will auto-detect float type</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
                <span class="k">pass</span>

        <span class="c1"># Default to String</span>
        <span class="k">if</span> <span class="n">literal</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">literal</span> <span class="o">=</span> <span class="n">OWLLiteral</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>  <span class="c1"># OWLLiteral will auto-detect string type</span>

        <span class="k">return</span> <span class="n">literal</span></div>


<div class="viewcode-block" id="GraphExtractor.generate_ontology">
<a class="viewcode-back" href="../../../autoapi/owlapy/agen_kg/graph_extractor/index.html#owlapy.agen_kg.graph_extractor.GraphExtractor.generate_ontology">[docs]</a>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">generate_ontology</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">],</span> <span class="n">ontology_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;open&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Ontology</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate an ontology from the given text or file.</span>
<span class="sd">        Must be implemented by subclasses.</span>

<span class="sd">        Args:</span>
<span class="sd">            text: Input text or file path to extract ontology from.</span>
<span class="sd">                Supports files: .txt, .pdf, .docx, .doc, .rtf, .html, .htm</span>
<span class="sd">            ontology_type (str): The ontology type to use. Options are:</span>
<span class="sd">                    1. &#39;domain&#39;: Focused on a specific domain (e.g., healthcare, finance),</span>
<span class="sd">                    2. &#39;cross-domain&#39;: Spans multiple related domains,</span>
<span class="sd">                    3. &#39;enterprise&#39;: Tailored for organizational knowledge representation,</span>
<span class="sd">                    4. &#39;open&#39;: General-purpose ontology covering a wide range of topics, similar to Wikidata.</span>
<span class="sd">            **kwargs: Additional arguments specific to the extractor type.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Generated Ontology object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright .</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>